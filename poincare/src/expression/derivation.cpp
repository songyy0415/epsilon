#include "derivation.h"

#include <poincare/src/memory/n_ary.h>
#include <poincare/src/memory/pattern_matching.h>

#include "dependency.h"
#include "dimension.h"
#include "k_tree.h"
#include "random.h"
#include "rational.h"
#include "set.h"
#include "systematic_reduction.h"
#include "variables.h"

namespace Poincare::Internal {

bool Derivation::Reduce(Tree* e) {
  // Tree's children are expected to have been reduced beforehand.
  assert(e->isDiff());
  const Tree* symbol = e->child(0);
  const Tree* symbolValue = symbol->nextTree();
  const Tree* order = symbolValue->nextTree();
  const Tree* constDerivand = order->nextTree();

  // Distribute derivation on points.
  if (constDerivand->isPoint()) {
    /* Points could be handled in Derive in the general case with
     * Diff(Point(KA,KB)) = (1, 0) * Diff(KA) + (0, 1) * Diff(KB)
     * but sums and product of points are not handled. We escape the case with
     * diff((f(y), g(y)), y, x) -> (diff(f(y), y, x), diff(g(y), y, x)) */
    Tree* pointDiff = PatternMatching::Create(
        KPoint(KDiff(KA, KB, KC, KD), KDiff(KA, KB, KC, KE)),
        {.KA = symbol,
         .KB = symbolValue,
         .KC = order,
         .KD = constDerivand->child(0),
         .KE = constDerivand->child(1)});
    Derivation::Reduce(pointDiff->child(0));
    Derivation::Reduce(pointDiff->child(1));
    SystematicReduction::ShallowReduce(pointDiff);
    e->moveTreeOverTree(pointDiff);
    return true;
  }

  OMG::Troolean validOrder = Integer::IsPositiveRationalInteger(order);
  if (validOrder == OMG::Troolean::False) {
    e->cloneTreeOverTree(KUndefUnhandled);
    return true;
  }
  if (validOrder == OMG::Troolean::Unknown) {
    return false;
  }
  int derivationOrder = Integer::Handler(order).to<uint8_t>();

  // Derive the derivand successively, preserving local variable scope.
  Tree* derivative = constDerivand->cloneTree();
  int currentDerivationOrder = 0;
  while (currentDerivationOrder < derivationOrder) {
    Tree* nextDerivative = Derive(derivative, symbol, false);
    // Remove previous derivative
    if (!nextDerivative) {
      // Derivation wasn't handled.
      derivative->removeTree();
      // TODO is it worth to save the partial derivation if any ?
      return false;
    }
    derivative->moveTreeOverTree(nextDerivative);
    /* Remove the dependencies created during derivation reduction since they
     * were just generated by the calculation process and should already be
     * included in the final dependency.
     * TODO: Ensure the calculation process cannot generate useful dependencies.
     * Example: 3x is derived to 0*x+3*1 because we use the u'v+uv' formula. So
     * a dependency is created on x (because of 0*x), but 3x is already a
     * dependency. */
    Dependency::RemoveDependencies(derivative);
    if (derivative->isZero()) {
      // Early escape null derivative
      currentDerivationOrder = derivationOrder;
    } else {
      currentDerivationOrder++;
    }
  }

  Variables::LeaveScopeWithReplacement(derivative, symbolValue, true, false);

  // Add a dependency on initial derivand if anything has been derived.
  if (derivationOrder > 0 && !derivative->isUndefined()) {
    // diff(f(y), y, x) -> dep(f'(x), {f(x)})
    SharedTreeStack->pushDepList(1);
    Variables::LeaveScopeWithReplacement(constDerivand->cloneTree(),
                                         symbolValue, false, true);
    derivative->cloneNodeAtNode(KDep);
    SystematicReduction::ShallowReduce(derivative->child(1));
    SystematicReduction::ShallowReduce(derivative);
  }

  e->moveTreeOverTree(derivative);
  return true;
}

// Derive derivand preserving scope (V0^2 -> 2*V0).
Tree* Derivation::Derive(const Tree* derivand, const Tree* symbol, bool force) {
  assert(Dimension::Get(derivand).isScalar());
  if (derivand->treeIsIdenticalTo(KVarX)) {
    // V0 -> 1
    return (1_e)->cloneTree();
  }
  /* Merge subsequent nested derivatives. Avoid infinite simplification loops.
   * diff(f(V0), x, V0, n) -> diff(f(V0), x, V0, n+1) */
  PatternMatching::Context ctx;
  if (PatternMatching::Match(derivand, KDiff(KA, KVarX, KB, KC), &ctx)) {
    Tree* result =
        PatternMatching::Create(KDiff(KA, KVarX, KAdd(KB, 1_e), KC), ctx);
    SystematicReduction::ShallowReduce(result->child(2));
    return result;
  }
  if (Random::HasRandom(derivand)) {
    // Do not handle random nodes in derivation
    return KUndefUnhandled->cloneTree();
  }
  /* General case :
   * f(g0(V0), g1(V0), ...) -> ... + Di(f) * diff(gi(V0), symbol, V0) + ...
   * With Di the partial derivative on parameter i (see ShallowPartialDerivate)
   * If f has no children, derivand cannot depend of V0, and empty addition is 0
   * Ï€->0 */
  Tree* result = SharedTreeStack->pushAdd(0);
  int i = 0;
  for (const Tree* derivandChild : derivand->children()) {
    NAry::SetNumberOfChildren(result, i + 1);
    Tree* mult = SharedTreeStack->pushMult(0);
    if (!ShallowPartialDerivate(derivand, i)) {
      // Cancel current derivation.
      result->removeTree();
      if (!force) {
        return nullptr;
      }
      /* Fallback to Diff(derivand)
       * f(V0+V1) -> diff(f(V0+V2), symbol, V0) */
      Tree* preservedDerivative = SharedTreeStack->pushDiff();
      symbol->cloneTree();
      KVarX->cloneTree();
      (1_e)->cloneTree();
      Tree* nestedDerivand = derivand->cloneTree();
      Variables::EnterScopeExceptLocalVariable(nestedDerivand);
      return preservedDerivative;
    }

    Tree* tempDerivative = Derive(derivandChild, symbol, true);
    assert(tempDerivative);
    (void)tempDerivative;
    NAry::SetNumberOfChildren(mult, 2);
    SystematicReduction::ShallowReduce(mult);
    i++;
  }
  SystematicReduction::ShallowReduce(result);
  return result;
}

Tree* Derivation::ShallowPartialDerivate(const Tree* derivand, int index) {
  switch (derivand->type()) {
    case Type::Mult: {
      // Di(x0 * x1 * ... * xi * ...) = x0 * x1 * ... * xi-1 * xi+1 * ...
      int numberOfChildren = derivand->numberOfChildren();
      assert(numberOfChildren > 1 && index < numberOfChildren);
      Tree* mult = SharedTreeStack->pushMult(numberOfChildren - 1);
      for (IndexedChild<const Tree*> child : derivand->indexedChildren()) {
        if (child.index != index) {
          child->cloneTree();
        }
      }
      SystematicReduction::ShallowReduce(mult);
      return mult;
    }
    case Type::Add:
      // Di(x0 + x1 + ... + xi + ...) = 1
      return SharedTreeStack->pushOne();
    case Type::Exp:
      // Di(exp(x)) = exp(x)
      return derivand->cloneTree();
    case Type::Ln: {
      // Di(ln(x)) = 1/x
      Tree* power = SharedTreeStack->pushPow();
      derivand->child(0)->cloneTree();
      SharedTreeStack->pushMinusOne();
      SystematicReduction::ShallowReduce(power);
      return power;
    }
    case Type::Trig:
      // Di(Trig(x, n)) = Trig(x, n-1)
    case Type::Pow: {
      // Di(x^n) = n*x^(n-1)
      if (index == 1) {
        // Second parameter cannot depend on symbol.
        assert(!Variables::HasVariables(derivand->child(1)));
        return (0_e)->cloneTree();
      }
      Tree* multiplication;
      if (derivand->isPow()) {
        multiplication = SharedTreeStack->pushMult(2);
        derivand->child(1)->cloneTree();
      }
      Tree* newNode = derivand->cloneNode();
      derivand->child(0)->cloneTree();
      Tree* addition = SharedTreeStack->pushAdd(2);
      derivand->child(1)->cloneTree();
      (-1_e)->cloneTree();
      SystematicReduction::ShallowReduce(addition);
      SystematicReduction::ShallowReduce(newNode);
      if (derivand->isPow()) {
        SystematicReduction::ShallowReduce(multiplication);
      }
      return derivand->isPow() ? multiplication : newNode;
    }
    case Type::Abs: {
      /* Di(|x|) = sign(x) if x != 0 and undef if x = 0
       *         = x / |x| */
      Tree* multiplication = SharedTreeStack->pushMult(2);
      derivand->child(0)->cloneTree();
      Tree* power = SharedTreeStack->pushPow();
      derivand->cloneTree();
      SharedTreeStack->pushMinusOne();
      SystematicReduction::ShallowReduce(power);
      SystematicReduction::ShallowReduce(multiplication);
      return multiplication;
    }
    default:
      return nullptr;
  }
}

}  // namespace Poincare::Internal
