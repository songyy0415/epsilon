#include "derivation.h"

#include <poincare/src/memory/n_ary.h>
#include <poincare/src/memory/node_iterator.h>
#include <poincare/src/memory/pattern_matching.h>

#include "dependency.h"
#include "k_tree.h"
#include "rational.h"
#include "set.h"
#include "simplification.h"
#include "variables.h"

namespace Poincare::Internal {

bool Derivation::ShallowSimplify(Tree* node) {
  // Tree's children are expected to have been reduced beforehand.
  assert(node->isNthDiff());
  const Tree* symbol = node->child(0);
  const Tree* symbolValue = symbol->nextTree();
  const Tree* order = symbolValue->nextTree();
  if (!Integer::Is<uint8_t>(order)) {
    node->cloneTreeOverTree(KUndefUnhandled);
    return true;
  }
  int derivationOrder = Integer::Handler(order).to<uint8_t>();
  const Tree* constDerivand = order->nextTree();
  // Derivate the derivand successively, preserving local variable scope.
  Tree* derivative = constDerivand->clone();
  int currentDerivationOrder = 0;
  while (currentDerivationOrder < derivationOrder) {
    Tree* nextDerivative = Derivate(derivative, symbol, false);
    // Remove previous derivative
    if (!nextDerivative) {
      // Derivation wasn't handled.
      derivative->removeTree();
      // TODO is it worth to save the partial derivation if any ?
      return false;
    }
    derivative->moveTreeOverTree(nextDerivative);
    if (derivative->isDependency()) {
      /* Remove the dependencies created during derivation reduction since they
       * were just generated by the calculation process and should already be
       * included in the final dependency.
       * TODO: Ensure the calculation process cannot generate useful
       * dependencies.
       * Example: 3x is derived to 0*x+3*1 because we use the u'v+uv' formula.
       * So a dependency is created on x (because of 0*x), but 3x is already a
       * dependency. */
      derivative->moveTreeOverTree(Dependency::Main(derivative));
    }
    if (derivative->isZero()) {
      // Early escape null derivative
      currentDerivationOrder = derivationOrder;
    } else {
      currentDerivationOrder++;
    }
  }

  Variables::LeaveScopeWithReplacement(derivative, symbolValue, true);

  // Add a dependency on initial derivand if anything has been derived.
  if (derivationOrder > 0 && !derivative->isUndefined()) {
    // diff(f(y), y, x) -> dep(f'(x), {f(x)})
    SharedTreeStack->push<Type::Set>(1);
    Variables::LeaveScopeWithReplacement(constDerivand->clone(), symbolValue,
                                         false);
    derivative->cloneNodeAtNode(KDep);
  }

  node->moveTreeOverTree(derivative);
  return true;
}

// Derivate derivand preserving scope (V0^2 is derived to 2*V0).
Tree* Derivation::Derivate(const Tree* derivand, const Tree* symbol,
                           bool force) {
  if (derivand->treeIsIdenticalTo(KVarX)) {
    return (1_e)->clone();
  }
  // Merge subsequent nested derivatives. Avoid infinite simplification loops.
  PatternMatching::Context ctx;
  if (PatternMatching::Match(KNthDiff(KA, KVarX, KB, KC), derivand, &ctx)) {
    Tree* result =
        PatternMatching::Create(KNthDiff(KA, KVarX, KAdd(KB, 1_e), KC), ctx);
    Simplification::ShallowSystematicReduce(result->child(2));
    return result;
  }
  if (derivand->isPoint()) {
    /* Bubble-up the Point. We could have Di(Point) to be (i==0,i==1), but we
     * don't handle sums and product of points, so we escape the case here. */
    Tree* result = SharedTreeStack->push(Type::Point);
    Derivate(derivand->child(0), symbol, true);
    Derivate(derivand->child(1), symbol, true);
    Simplification::ShallowSystematicReduce(result);
    return result;
  }
  if (derivand->isRandomNode()) {
    // Do not handle random nodes in derivation.
    return KUndefUnhandled->clone();
  }
  int numberOfChildren = derivand->numberOfChildren();
  if (numberOfChildren == 0) {
    return (0_e)->clone();
  }

  Tree* result = SharedTreeStack->push<Type::Add>(0);
  const Tree* derivandChild = derivand->child(0);
  /* D(f(g0(x),g1(x), ...)) = Sum(Di(f)(g0(x),g1(x), ...)*D(gi(x)))
   * With D being the Derivative and Di being the partial derivative on
   * parameter i. */
  for (int i = 0; i < numberOfChildren; i++) {
    NAry::SetNumberOfChildren(result, i + 1);
    Tree* mult = SharedTreeStack->push<Type::Mult>(0);
    if (!ShallowPartialDerivate(derivand, i)) {
      // Cancel current derivation.
      result->removeTree();
      if (!force) {
        return nullptr;
      }
      // Fallback to Diff(derivand)
      Tree* preservedDerivative = SharedTreeStack->push(Type::NthDiff);
      symbol->clone();
      KVarX->clone();
      (1_e)->clone();
      Tree* nestedDerivand = derivand->clone();
      /* Scope is preserved in Derivation::Derivate. f(V0+V1) is derived to
       * diff(symbol, V0, f(V0+V2)). */
      Variables::EnterScopeExceptLocalVariable(nestedDerivand);
      return preservedDerivative;
    }
    NAry::SetNumberOfChildren(mult, 2);
    Derivate(derivandChild, symbol, true);
    Simplification::ShallowSystematicReduce(mult);
    derivandChild = derivandChild->nextTree();
  }
  Simplification::ShallowSystematicReduce(result);
  return result;
}

bool Derivation::ShallowPartialDerivate(const Tree* derivand, int index) {
  switch (derivand->type()) {
    case Type::Mult: {
      // Di(x0 * x1 * ... * xi * ...) = x0 * x1 * ... * xi-1 * xi+1 * ...
      int numberOfChildren = derivand->numberOfChildren();
      assert(numberOfChildren > 1 && index < numberOfChildren);
      Tree* mult;
      if (numberOfChildren > 2) {
        mult = SharedTreeStack->push<Type::Mult>(numberOfChildren - 1);
      }
      for (std::pair<const Tree*, int> indexedNode :
           NodeIterator::Children<NoEditable>(derivand)) {
        if (indexedNode.second != index) {
          indexedNode.first->clone();
        }
      }
      if (numberOfChildren > 2) {
        Simplification::ShallowSystematicReduce(mult);
      }
      return true;
    }
    case Type::Add:
      // Di(x0 + x1 + ... + xi + ...) = 1
      SharedTreeStack->push(Type::One);
      return true;
    case Type::Exp:
      // Di(exp(x)) = exp(x)
      derivand->clone();
      return true;
    case Type::LnReal:
    case Type::Ln: {
      // Di(ln(x)) = 1/x
      Tree* power = SharedTreeStack->push(Type::Pow);
      derivand->child(0)->clone();
      SharedTreeStack->push(Type::MinusOne);
      Simplification::ShallowSystematicReduce(power);
      return true;
    }
    case Type::Trig:
      // Di(Trig(x, n)) = Trig(x, n-1)
    case Type::Pow: {
      // Di(x^n) = n*x^(n-1)
      // Second parameter cannot depend on symbol.
      assert(!Variables::HasVariables(derivand->child(1)));
      if (index == 1) {
        SharedTreeStack->push(Type::Zero);
        return true;
      }
      Tree* multiplication;
      if (derivand->isPow()) {
        multiplication = SharedTreeStack->push<Type::Mult>(2);
        SharedTreeStack->clone(derivand->child(1));
      }
      Tree* newNode = SharedTreeStack->clone(derivand, false);
      derivand->child(0)->clone();
      Tree* addition = SharedTreeStack->push<Type::Add>(2);
      SharedTreeStack->clone(derivand->child(1));
      SharedTreeStack->push(Type::MinusOne);
      Simplification::ShallowSystematicReduce(addition);
      Simplification::ShallowSystematicReduce(newNode);
      if (derivand->isPow()) {
        Simplification::ShallowSystematicReduce(multiplication);
      }
      return true;
    }
    default:
      return false;
  }
}

}  // namespace Poincare::Internal
