#include "derivation.h"

#include <poincare_junior/src/expression/dependency.h>
#include <poincare_junior/src/expression/k_tree.h>
#include <poincare_junior/src/expression/rational.h>
#include <poincare_junior/src/expression/set.h>
#include <poincare_junior/src/expression/simplification.h>
#include <poincare_junior/src/expression/variables.h>
#include <poincare_junior/src/memory/exception_checkpoint.h>
#include <poincare_junior/src/memory/node_iterator.h>
#include <poincare_junior/src/n_ary.h>

namespace PoincareJ {

bool Derivation::ShallowSimplify(Tree* node) {
  // Tree is expected to have been reduced beforehand.
  assert(node->isDerivative() || node->isNthDerivative());
  const Tree* symbol = node->child(0);
  const Tree* symbolValue = symbol->nextTree();
  const Tree* constDerivand;
  int derivationOrder;
  if (node->isDerivative()) {
    derivationOrder = 1;
    constDerivand = symbolValue->nextTree();
  } else {
    const Tree* order = symbolValue->nextTree();
    if (!Integer::Is<uint8_t>(order)) {
      ExceptionCheckpoint::Raise(ExceptionType::Unhandled);
    }
    derivationOrder = Integer::Handler(order).to<uint8_t>();
    constDerivand = order->nextTree();
  }
  Tree* setOfDependencies;
  Tree* derivand;
  if (constDerivand->isDependency()) {
    setOfDependencies =
        CloneReplacingSymbol(constDerivand->child(1), symbolValue, false);
    derivand = constDerivand->child(0)->clone();
  } else {
    setOfDependencies = Set::PushEmpty();
    derivand = constDerivand->clone();
  }

  int currentDerivationOrder = derivationOrder;
  while (currentDerivationOrder > 0) {
    Tree* derivative = Derivate(derivand, symbolValue, symbol);
    if (!derivative) {
      // TODO is it worth to save the partial derivation if any ?
      derivand->removeTree();
      setOfDependencies->removeTree();
      return false;
    }
    if (derivative->isDependency()) {
      /* Remove the dependencies created during derivation reduction since they
       * were just generated by the calculation process and should already be
       * included in the derivand dependency.
       * TODO : Ensure the calculation process cannot generate useful
       * dependencies.
       * Example: 3x is derivated to 0*x+3*1 because we use the u'v+uv' formula.
       * So a dependency is created on x (because of 0*x), but 3x is already a
       * dependency. */
      derivative->moveTreeOverTree(derivative->child(0));
    }
    if (derivative->isZero()) {
      currentDerivationOrder = 0;
    } else {
      currentDerivationOrder--;
    }
    derivand->removeTree();
  }

  SwapTreesPointers(&derivand, &setOfDependencies);
  // Do not add a dependency if nothing was derivated.
  if (currentDerivationOrder < derivationOrder) {
    TreeRef formula = CloneReplacingSymbol(constDerivand, symbolValue);
    Set::Add(setOfDependencies, formula);
    formula->removeTree();
  }

  if (setOfDependencies->numberOfChildren() > 0) {
    derivand->cloneNodeAtNode(KDep);
    Dependency::RemoveDefinedDependencies(derivand);
  } else {
    setOfDependencies->removeTree();
  }

  node->moveTreeOverTree(derivand);
  return true;
}

Tree* Derivation::Derivate(const Tree* derivand, const Tree* symbolValue,
                           const Tree* symbol) {
  if (derivand->treeIsIdenticalTo(KVarX)) {
    return (1_e)->clone();
  }
  if (derivand->isRandomNode()) {
    // Do not handle random nodes in derivation.
    ExceptionCheckpoint::Raise(ExceptionType::Unhandled);
  }
  int numberOfChildren = derivand->numberOfChildren();
  if (numberOfChildren == 0) {
    return (0_e)->clone();
  }

  Tree* result = SharedTreeStack->push<Type::Addition>(0);
  const Tree* derivandChild = derivand->nextNode();
  /* D(f(g0(x),g1(x), ...)) = Sum(D(gi(x))*Di(f)(g0(x),g1(x), ...))
   * With D being the Derivative and Di being the partial derivative on
   * parameter i. */
  for (int i = 0; i < numberOfChildren; i++) {
    NAry::SetNumberOfChildren(result, i + 1);
    Tree* mult = SharedTreeStack->push<Type::Multiplication>(1);
    if (!Derivate(derivandChild, symbolValue, symbol)) {
      // Could not derivate, preserve D(gi(x))
      SharedTreeStack->push(Type::Derivative);
      symbol->clone();
      symbolValue->clone();
      derivandChild->clone();
    }
    if (!ShallowPartialDerivate(derivand, symbolValue, i)) {
      // Cancel current derivation.
      result->removeTree();
      return nullptr;
    }
    NAry::SetNumberOfChildren(mult, 2);
    Simplification::ShallowSystematicReduce(mult);
    derivandChild = derivandChild->nextTree();
  }
  Simplification::ShallowSystematicReduce(result);
  return result;
}

bool Derivation::ShallowPartialDerivate(const Tree* derivand,
                                        const Tree* symbolValue, int index) {
  switch (derivand->type()) {
    case Type::Multiplication: {
      // Di(x0 * x1 * ... * xi * ...) = x0 * x1 * ... * xi-1 * xi+1 * ...
      int numberOfChildren = derivand->numberOfChildren();
      assert(numberOfChildren > 1 && index < numberOfChildren);
      Tree* mult;
      if (numberOfChildren > 2) {
        mult =
            SharedTreeStack->push<Type::Multiplication>(numberOfChildren - 1);
      }
      for (std::pair<const Tree*, int> indexedNode :
           NodeIterator::Children<NoEditable>(derivand)) {
        if (indexedNode.second != index) {
          CloneReplacingSymbol(indexedNode.first, symbolValue);
        }
      }
      if (numberOfChildren > 2) {
        Simplification::ShallowSystematicReduce(mult);
      }
      return true;
    }
    case Type::Addition:
      // Di(x0 + x1 + ... + xi + ...) = 1
      SharedTreeStack->push(Type::One);
      return true;
    case Type::Exponential:
      // Di(exp(x)) = exp(x)
      CloneReplacingSymbol(derivand, symbolValue);
      return true;
    case Type::LnReal:
    case Type::Ln: {
      // Di(ln(x)) = 1/x
      Tree* power = SharedTreeStack->push(Type::Power);
      CloneReplacingSymbol(derivand->child(0), symbolValue);
      SharedTreeStack->push(Type::MinusOne);
      Simplification::ShallowSystematicReduce(power);
      return true;
    }
    case Type::Trig:
      // Di(Trig(x, n)) = Trig(x, n-1)
    case Type::Power: {
      // Di(x^n) = n*x^(n-1)
      // Second parameter cannot depend on symbol.
      assert(!Variables::HasVariables(derivand->child(1)));
      if (index == 1) {
        SharedTreeStack->push(Type::Zero);
        return true;
      }
      Tree* multiplication;
      if (derivand->isPower()) {
        multiplication = SharedTreeStack->push<Type::Multiplication>(2);
        SharedTreeStack->clone(derivand->child(1));
      }
      Tree* newNode = SharedTreeStack->clone(derivand, false);
      CloneReplacingSymbol(derivand->child(0), symbolValue);
      Tree* addition = SharedTreeStack->push<Type::Addition>(2);
      SharedTreeStack->clone(derivand->child(1));
      SharedTreeStack->push(Type::MinusOne);
      Simplification::ShallowSystematicReduce(addition);
      Simplification::ShallowSystematicReduce(newNode);
      if (derivand->isPower()) {
        Simplification::ShallowSystematicReduce(multiplication);
      }
      return true;
    }
    default:
      return false;
  }
}

Tree* Derivation::CloneReplacingSymbol(const Tree* expression,
                                       const Tree* symbolValue, bool simplify) {
  Tree* result = expression->clone();
  Variables::LeaveScopeWithReplacement(result, symbolValue, simplify);
  return result;
}

// TODO: Diff(g(x,y),y,h(x,y)) -> Diff(g(f(y),z),z,h(f(y),y))
// Diff(g(x),z,h(x)) -> Diff(g(f(y)),z,h(f(y)))

}  // namespace PoincareJ
