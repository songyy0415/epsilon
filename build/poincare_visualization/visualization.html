<!DOCTYPE html>
<html>
<meta charset="utf-8"/>
<title>Poincare Logs</title>
<style type="text/css">

svg {
  font: 10px sans-serif;
  height: 40px;
}

rect.highlight {
  height: 40px;
  stroke:red;
  stroke-width:3;
  fill: transparent;
}

rect.reference {
  height: 40px;
  stroke:#edaa30;
  stroke-width:1;
  fill: transparent;
}

rect.node {
  height: 28px;
  stroke:black;
  stroke-width:1;
  opacity:0.5;
}

rect.node:hover {
  y: 10;
  height: 30px;
  fill: #edaa30;
  opacity:1;
  stroke: #edaa30;
}

text {
  fill: black;
  font-family: Verdana;
}

.chart div {
}

</style>

<h2>Chart</h2>
<p id="chart" class="chart">

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<script type="text/javascript">

let nodeColors = {}

d3.xml("XML_FILE", function(err, xml) {
  let scale = 30
  let textHeight = 11

  let nodesSet = new Set()
  initialize(xml.documentElement, nodesSet)

  let poolEvent = d3.select("#chart")
    .selectAll("div")
    .data(xml.documentElement.children)
    .enter()
    .append("div")
    .attr("style", (d) => { return displayEvent(d) ? "" : "display: none" })

  let pootEventLabel = poolEvent.append("p")
    .text((d) => { return eventName(d); })

  let svg = poolEvent.append("svg")
    .attr("width", (d) => { return poolSize(d) })

  let reference = svg.selectAll("svg")
    .data((d) => { return references(d); })
    .enter()

  let referenceRect = reference.append("rect")
      .attr("class", "reference")
      .attr("width", (d) => { return d.width; })
      .attr("x", (d) => { return d.x; })

  let referenceLabel = reference.append("text")
    .text((d) => { return "Refs: " + d.getAttribute('id').replace(',','') })
      .attr("x", (d) => { return d.x + 3; })
      .attr("y", (d) => { return textHeight; })

  let node = svg.selectAll("svg")
    .data((d) => { return nodes(d); })
    .enter()

  let highlightedNodeRect = node.append("rect")
      .attr("class", "highlight")
      .attr("width", (d) => { return d.nodeWidth; })
      .attr("x", (d) => { return d.x; })
      .attr("visibility", (d) => { return d.highlighted ? "visible" : "hidden" })

  let highlightedNodePointer = node.append("rect")
      .attr("class", "highlight")
      .attr("visibility", (d) => { return d.pointerOffset < 0 ? "hidden" : "visible" })
      .attr("width", (d) => { return 4; })
      .attr("x", (d) => { return d.x + d.pointerOffset; })

  let nodeRect = node.append("rect")
    .attr("class", "node")
    .attr("fill", (d) => { return nodeColor(d, nodesSet); })
    .attr("x", (d) => { return d.x; })
    .attr("y", (d) => { return 12; })
    .attr("width", (d) => { return d.treeWidth; })

    let nodeLabel = node.append("text")
    .text((d) => { return d.nodeName.slice(0, d.nodeWidth / (0.2 * scale)) })
    .attr("x", (d) => { return d.x; })
    .attr("y", (d) => { return 2 * textHeight; })
    .attr("width", (d) => { return d.nodeWidth; })

  let nodeAttribute = node.append("text")
    .text((d) => { return nodeAttributes(d).slice(0, d.nodeWidth / (0.2 * scale)) })
    .attr("x", (d) => { return d.x; })
    .attr("y", (d) => { return 3 * textHeight; })
    .attr("width", (d) => { return d.nodeWidth; })

  function initializeNode(node, offset, nodesSet, eventBlockAddress, eventBlockSize, eventPointerAddress) {
    let nodeSize = parseInt(node.getAttribute('size'))
    let nodeWidth = nodeSize * scale
    let treeWidth = nodeWidth
    for (const childNode of node.children) {
      initializeNode(childNode, offset + treeWidth, nodesSet, eventBlockAddress, eventBlockSize, eventPointerAddress)
      treeWidth += childNode.treeWidth
    }
    node.x = offset
    node.treeWidth = treeWidth
    node.nodeWidth = nodeWidth
    nodesSet.add(node.nodeName)
    let nodeAddress = parseInt(node.getAttribute("address"), 16)
    node.highlighted = eventBlockAddress && nodeAddress >= eventBlockAddress && nodeAddress < eventBlockAddress + eventBlockSize
    if (eventPointerAddress >= nodeAddress && eventPointerAddress < nodeAddress + nodeSize) {
      node.pointerOffset = eventPointerAddress - nodeAddress
    } else {
      node.pointerOffset = -1
    }
  }

  function initialize(data, nodesSet) {
    let poolEvents = data.children
    for (const poolEvent of poolEvents) {
      poolEvent.occurences = 1
      let refs = references(poolEvent)
      let referenceOffset = 0
      let eventBlockAddress = parseInt(poolEvent.getAttribute("blockAddress"), 16)
      let eventBlockSize = parseInt(poolEvent.getAttribute("blockSize"))
      let eventPointerAddress = parseInt(poolEvent.getAttribute("pointerAddress"), 16)
      for (const reference of refs) {
        let rootNode = reference.firstElementChild
        initializeNode(rootNode, referenceOffset, nodesSet, eventBlockAddress, eventBlockSize, eventPointerAddress)
        reference.x = referenceOffset
        reference.width = rootNode.treeWidth
        referenceOffset += rootNode.treeWidth
      }
    }
  }

  function references(data) {
    return data.firstElementChild.children
  }

  function nodes(data) {
    function nodesRec(currentNode) {
      let nodes = []
      nodes.push(currentNode)
      for (const node of currentNode.children) {
        nodes = nodes.concat(nodesRec(node))
      }
      return nodes
    }
    let nodes = []
    let refs = references(data)
    for (const ref of refs) {
      let rootNode = ref.firstElementChild
      nodes = nodes.concat(nodesRec(rootNode))
    }
    return nodes
  }

  function eventName(eventNode) {
    let text = eventNode.nodeName + " (" + eventNode.occurences + ")"
    for (const name of eventNode.getAttributeNames()) {
      text = text + " " + name + ": " + eventNode.getAttribute(name)
    }
    return text
  }

  function displayEvent(eventNode) {
    if (eventNode.nodeName !== "Flush" || eventNode.nextElementSibling === null || eventNode.nextElementSibling.nodeName !== "Flush") {
      // Don't display consecutive Flush
      return true
    }
    // Count the number of skipped events
    eventNode.nextElementSibling.occurences = eventNode.nextElementSibling.occurences + eventNode.occurences
    return false
  }

  function poolSize(eventNode) {
    return eventNode.firstElementChild.getAttribute('size') * scale + "px"
  }

  function nodeColor(nodeNode, nodesSet) {
    var myColor = d3.scaleOrdinal().domain(Array.from(nodesSet)).range(d3.schemeSet3);
    return myColor(nodeNode.nodeName)
  }

  function nodeAttributes(nodeNode) {
    let text = ""
    for (const name of nodeNode.getAttributeNames()) {
      if (name === "size" || name === "address") {
        continue;
      }
      text = text + " " + name.slice(0, 5) + ": " + nodeNode.getAttribute(name)
    }
    return text
  }
})

</script>
</body>
</html>
