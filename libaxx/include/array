#ifndef LIBAXX_ARRAY
#define LIBAXX_ARRAY

#include <stddef.h>

#include <initializer_list>

namespace std {

template <class T, size_t N>
constexpr size_t size(const T (&array)[N]) noexcept {
  return N;
}

// template <typename U, unsigned int N> class array;

// template <unsigned int K, typename U, unsigned int N> U get(array<U, N>
// array);

template <typename U, unsigned int N>
class array {
  // friend U get(array);
 public:
  array() {}
  constexpr array(initializer_list<U> init) {
    int index = 0;
    for (const U &u : init) {
      m_array[index++] = u;
    }
  }
  constexpr U& operator[](unsigned int n) {
    return m_array[n];
  }

 private:
  U m_array[N];
};
/*
template <unsigned int K, typename U, unsigned int N>
U get(array<U, N> array) {
  static_assert(K<N, "out-of-bound access");
  return array.m_array[K];
}
*/
}  // namespace std

#endif
